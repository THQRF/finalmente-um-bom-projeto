<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Battle Arena Ultra P2P - Pro Evolution</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: 'Segoe UI', sans-serif; color: white; user-select: none; }
        canvas { display: block; background: #1a1a1a; }
        #ui-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.85); z-index: 10; }
        .menu { background: #2c3e50; padding: 30px; border-radius: 15px; text-align: center; width: 420px; border: 2px solid #34495e; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        .skill-box { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0; }
        .skill-btn { padding: 8px; font-size: 12px; background: #34495e; border: 1px solid #2ecc71; cursor: pointer; color: white; transition: 0.2s; border-radius: 4px; }
        .skill-btn:hover { background: #3e5871; }
        .skill-btn.selected { background: #2ecc71; color: #000; font-weight: bold; }
        input, button, textarea { width: 95%; margin: 10px 0; padding: 12px; border-radius: 8px; border: none; box-sizing: border-box; }
        button { background: #27ae60; color: white; font-weight: bold; cursor: pointer; text-transform: uppercase; transition: 0.3s; }
        button:hover { background: #2ecc71; transform: scale(1.02); }
        textarea { height: 60px; font-size: 10px; font-family: monospace; resize: none; background: #ecf0f1; }
        
        #hud { position: absolute; top: 20px; left: 20px; pointer-events: none; z-index: 5; text-shadow: 2px 2px 4px black; }
        #stats-panel { font-size: 14px; color: #bdc3c7; margin-top: 5px; background: rgba(0,0,0,0.3); padding: 5px; border-radius: 5px; }
        #scoreboard { position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.6); padding: 15px; border-radius: 8px; min-width: 150px; z-index: 5; border: 1px solid #444; }
        #minimap { position: absolute; bottom: 20px; right: 20px; width: 150px; height: 150px; background: rgba(0,0,0,0.7); border: 2px solid #555; border-radius: 4px; z-index: 5; }
        
        #btn-quit { position: absolute; bottom: 20px; left: 20px; padding: 10px 20px; background: #c0392b; color: white; border: none; border-radius: 5px; cursor: pointer; z-index: 100; display: none; }
        .save-badge { font-size: 10px; color: #2ecc71; display: none; margin-top: 5px; }
        .hidden { display: none !important; }
        .pvp-warn { color: #f1c40f; font-size: 10px; margin-top: -10px; margin-bottom: 10px; }
    </style>
</head>
<body>

<button id="btn-quit" onclick="location.reload()">SAIR DA ARENA</button>

<div id="hud" class="hidden">
    <div id="status-hp" style="color: #ff4757; font-size: 28px; font-weight: bold;">Vida: 100%</div>
    <div id="status-xp" style="color: #f1c40f; font-size: 18px;">Nível 1 (0/100 XP)</div>
    <div id="stats-panel">Dano: 20 | Vel: 5.0</div>
    <div id="status-skill" style="color: #2ecc71; font-size: 18px;">Habilidade: [M2] | Espadada: [R]</div>
    <div id="save-notification" class="save-badge">✓ PROGRESSO SALVO</div>
</div>

<div id="scoreboard" class="hidden">
    <div style="color: #2ecc71; font-weight: bold; margin-bottom: 5px;">PLACAR</div>
    <div id="score-me">Você: 0</div>
    <div id="score-enemy">Inimigos: 0</div>
</div>

<canvas id="minimap" class="hidden"></canvas>

<div id="ui-overlay">
    <div id="main-menu" class="menu">
        <h1 style="color:#2ecc71; margin-top:0;">BATTLE ARENA PRO</h1>
        <div style="background: rgba(0,0,0,0.2); padding: 10px; border-radius: 10px; margin-bottom: 15px;">
            <p style="margin: 0 0 10px 0; font-size: 13px;">Gerenciar Dados (.txt)</p>
            <div style="display: flex; gap: 5px;">
                <button onclick="exportCharacter()" style="font-size: 10px; background: #34495e;">Exportar Backup</button>
                <button onclick="importCharacter()" style="font-size: 10px; background: #34495e;">Importar Backup</button>
            </div>
        </div>
        <input type="text" id="nickname" placeholder="Nome do Jogador" maxlength="10">
        <p>Habilidade Especial:</p>
        <div class="skill-box">
            <div class="skill-btn" id="btn-speed" onclick="selectSkill('speed', this)">Velocidade++</div>
            <div class="skill-btn" id="btn-tank" onclick="selectSkill('tank', this)">Blindagem (HP+)</div>
            <div class="skill-btn" id="btn-teleport" onclick="selectSkill('teleport', this)">Teleporte</div>
            <div class="skill-btn" id="btn-rapid" onclick="selectSkill('rapid', this)">Tiro Rápido</div>
            <div class="skill-btn" id="btn-ghost" onclick="selectSkill('ghost', this)">Invisibilidade</div>
        </div>
        <input type="color" id="playerColor" value="#e74c3c" style="height: 40px; padding: 2px;">
        <button onclick="showLobby()">INICIAR ARENA</button>
    </div>
    <div id="lobby-menu" class="menu hidden">
        <h2>MODO DE JOGO</h2>
        <button onclick="startOffline()" style="background:#8e44ad">Treinamento Offline (Bots)</button>
        <hr style="border: 0; border-top: 1px solid #444; margin: 20px 0;">
        <p class="pvp-warn">No PvP, todos os jogadores tem atributos iguais!</p>
        <button onclick="startHost()">Criar Sala (Host)</button>
        <button onclick="showJoin()" style="background:#2980b9">Entrar em Sala</button>
        <button onclick="backToMain()" style="background:#7f8c8d; font-size: 10px;">Voltar</button>
    </div>
    <div id="host-setup" class="menu hidden">
        <p>1. Envie este código ao amigo:</p>
        <textarea id="offer-token" readonly onclick="this.select()"></textarea>
        <p>2. Cole a resposta dele aqui:</p>
        <textarea id="answer-token" placeholder="Cole a resposta aqui..."></textarea>
        <button onclick="confirmHost()">CONECTAR AGORA</button>
    </div>
    <div id="join-setup" class="menu hidden">
        <p>1. Cole o código do Host:</p>
        <textarea id="join-offer" placeholder="Cole o código aqui..." oninput="autoGenerateAnswer()"></textarea>
        <p>2. Envie sua resposta ao Host:</p>
        <textarea id="join-answer" readonly onclick="this.select()"></textarea>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/** SISTEMA DE SOM **/
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(freq, type, duration, vol) {
    try {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    } catch(e) {}
}

const SFX = {
    shoot: () => playSound(440, 'triangle', 0.1, 0.1),
    hit: () => playSound(150, 'sawtooth', 0.2, 0.2),
    levelUp: () => { playSound(523, 'sine', 0.5, 0.2); setTimeout(()=>playSound(659, 'sine', 0.5, 0.2), 100); },
    skill: () => playSound(880, 'sine', 0.3, 0.1),
    heal: () => playSound(600, 'sine', 0.4, 0.2),
    sword: () => playSound(200, 'sawtooth', 0.3, 0.3)
};

/** CONFIGURAÇÕES **/
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const miniCanvas = document.getElementById('minimap');
const mctx = miniCanvas.getContext('2d');

const WORLD = { width: 3500, height: 3500 };
let camera = { x: 0, y: 0 };
let isOffline = false;
let gameRunning = false;

let player = {
    x: 1750, y: 1750, size: 22, color: '#e74c3c', name: '', 
    hp: 100, maxHp: 100, score: 0, skill: 'speed', skillCD: 0,
    invisible: false, lastFire: 0, fireRate: 400,
    xp: 0, level: 1, baseSpeed: 5, damage: 20, bulletSpeed: 12,
    swordCD: 0, swordActive: 0
};

let bots = [];
let opponent = { x: -5000, y: -5000, size: 22, hp: 100, maxHp: 100, score: 0, invisible: false, name: 'Inimigo', color: '#3498db', swordActive: 0 };
let projectiles = [];
let obstacles = [];
let items = [];
let keys = {};
let mousePos = { x: 0, y: 0 };

/** SISTEMA DE SALVAMENTO **/
function saveToStorage() {
    if(!isOffline) return; // Não salva progresso em PVP Arena
    const saveData = {
        name: player.name, color: player.color, skill: player.skill,
        xp: player.xp, level: player.level, score: player.score,
        maxHp: player.maxHp, damage: player.damage, baseSpeed: player.baseSpeed
    };
    localStorage.setItem('battle_arena_save', JSON.stringify(saveData));
    showSaveBadge();
}

function loadFromStorage() {
    const saved = localStorage.getItem('battle_arena_save');
    if(saved) {
        const data = JSON.parse(saved);
        Object.assign(player, data);
        document.getElementById('nickname').value = data.name;
        document.getElementById('playerColor').value = data.color;
        const btn = document.getElementById('btn-' + data.skill);
        if(btn) selectSkill(data.skill, btn);
        return true;
    }
    return false;
}

function showSaveBadge() {
    const badge = document.getElementById('save-notification');
    if(badge) {
        badge.style.display = 'block';
        setTimeout(() => badge.style.display = 'none', 2000);
    }
}

/** MECÂNICAS NOVAS **/

function spawnItems() {
    for(let i=0; i<15; i++) {
        items.push({
            x: Math.random() * WORLD.width,
            y: Math.random() * WORLD.height,
            type: 'heal',
            val: 40
        });
    }
}

function swordAttack() {
    if(player.swordCD > 0 || player.hp <= 0) return;
    player.swordCD = 120; // 2 segundos
    player.swordActive = 20; // Duração visual/dano
    SFX.sword();
    
    // Área de dano da espada (360 graus em volta do player)
    const range = 100;
    const dmg = isOffline ? player.damage * 2.5 : 50;

    if(isOffline) {
        bots.forEach(bot => {
            if(Math.hypot(player.x - bot.x, player.y - bot.y) < range) {
                bot.hp -= dmg;
                SFX.hit();
                if(bot.hp <= 0) { player.score++; addXP(45); }
            }
        });
    } else {
        if(Math.hypot(player.x - opponent.x, player.y - opponent.y) < range) {
            sendData({ type: 'hit', damage: dmg, method: 'sword' });
        }
    }
    sendData({ type: 'sword' });
}

/** PROGRESSÃO **/
function addXP(amount) {
    if(!isOffline) return; 
    player.xp += amount;
    let nextLevelXp = player.level * 100;
    if(player.xp >= nextLevelXp) {
        player.xp -= nextLevelXp;
        player.level++;
        player.maxHp += 15;
        player.hp = player.maxHp;
        player.damage += 5;
        player.baseSpeed += 0.2;
        SFX.levelUp();
        saveToStorage();
    }
}

/** LÓGICA PRINCIPAL **/
function initGame() {
    gameRunning = true;
    generateMap();
    spawnItems();
    
    document.getElementById('btn-quit').style.display = 'block';
    document.getElementById('hud').classList.remove('hidden');
    document.getElementById('scoreboard').classList.remove('hidden');
    document.getElementById('minimap').classList.remove('hidden');

    if(!isOffline) {
        // Resetar para Atributos Base no PVP
        player.maxHp = 200;
        player.hp = 200;
        player.damage = 25;
        player.baseSpeed = 6;
        player.level = 1;
        
        // Pouquíssimos NPCs no PVP (Apenas 2 bots)
        for(let i=0; i<2; i++) spawnBot();
    } else {
        // Aplicar bônus de classe se for offline
        if(player.skill === 'tank') { player.maxHp += 100; player.hp = player.maxHp; player.baseSpeed -= 1; }
        if(player.skill === 'speed') { player.baseSpeed += 2; }
        if(player.skill === 'rapid') { player.fireRate = 180; }
        for(let i=0; i<8; i++) spawnBot();
    }

    respawn();
    requestAnimationFrame(gameLoop);
}

function update() {
    if(player.hp <= 0) return;

    // Movimentação
    let moveX = 0, moveY = 0;
    if(keys['w']) moveY -= player.baseSpeed;
    if(keys['s']) moveY += player.baseSpeed;
    if(keys['a']) moveX -= player.baseSpeed;
    if(keys['d']) moveX += player.baseSpeed;

    if(!checkCollision(player.x + moveX, player.y, player.size)) player.x += moveX;
    if(!checkCollision(player.x, player.y + moveY, player.size)) player.y += moveY;

    // Limites do Mundo
    player.x = Math.max(player.size, Math.min(WORLD.width - player.size, player.x));
    player.y = Math.max(player.size, Math.min(WORLD.height - player.size, player.y));

    camera.x = player.x - canvas.width / 2;
    camera.y = player.y - canvas.height / 2;

    // Cooldowns
    if(player.skillCD > 0) player.skillCD--;
    if(player.swordCD > 0) player.swordCD--;
    if(player.swordActive > 0) player.swordActive--;

    // Itens de Cura
    items.forEach((item, index) => {
        if(Math.hypot(player.x - item.x, player.y - item.y) < player.size + 15) {
            player.hp = Math.min(player.maxHp, player.hp + item.val);
            items.splice(index, 1);
            SFX.heal();
            setTimeout(() => {
                items.push({ x: Math.random()*WORLD.width, y: Math.random()*WORLD.height, type: 'heal', val: 40 });
            }, 10000);
        }
    });

    // IA Bots
    bots.forEach((bot, bIdx) => {
        const dist = Math.hypot(player.x - bot.x, player.y - bot.y);
        if(dist < 500 && !player.invisible) {
            const angle = Math.atan2(player.y - bot.y, player.x - bot.x);
            bot.x += Math.cos(angle) * bot.speed;
            bot.y += Math.sin(angle) * bot.speed;
            if(Date.now() - bot.lastFire > 2000) {
                projectiles.push({
                    x: bot.x, y: bot.y, vx: Math.cos(angle) * 8, vy: Math.sin(angle) * 8,
                    owner: 'opponent', color: bot.color, damage: 15
                });
                bot.lastFire = Date.now();
                SFX.shoot();
            }
        }
    });

    // Projéteis
    for(let i = projectiles.length - 1; i >= 0; i--) {
        let p = projectiles[i];
        p.x += p.vx; p.y += p.vy;

        if(checkCollision(p.x, p.y, 5)) { projectiles.splice(i, 1); continue; }

        if(p.owner === 'opponent') {
            if(Math.hypot(p.x - player.x, p.y - player.y) < player.size && !player.invisible) {
                player.hp -= p.damage;
                SFX.hit();
                projectiles.splice(i, 1);
                if(player.hp <= 0) { respawn(); saveToStorage(); }
            }
        } else {
            // Dano em Bots
            bots.forEach((bot, bIdx) => {
                if(Math.hypot(p.x - bot.x, p.y - bot.y) < bot.size) {
                    bot.hp -= player.damage;
                    SFX.hit();
                    projectiles.splice(i, 1);
                    if(bot.hp <= 0) { bots.splice(bIdx, 1); player.score++; addXP(45); setTimeout(spawnBot, 5000); }
                }
            });
            // Dano em Player Oponente
            if(!isOffline && Math.hypot(p.x - opponent.x, p.y - opponent.y) < opponent.size) {
                projectiles.splice(i, 1);
                sendData({ type: 'hit', damage: player.damage });
            }
        }
    }

    // UI Updates
    document.getElementById('status-hp').innerText = `Vida: ${Math.max(0, Math.ceil(player.hp))}`;
    document.getElementById('status-xp').innerText = isOffline ? `Nível ${player.level} (${player.xp}/${player.level*100} XP)` : "Modo Arena (Equilibrado)";
    document.getElementById('score-me').innerText = `${player.name}: ${player.score}`;

    if(!isOffline) sendData({ 
        type: 'pos', x: player.x, y: player.y, hp: player.hp, maxHp: player.maxHp, 
        score: player.score, inv: player.invisible, color: player.color, 
        name: player.name, sa: player.swordActive 
    });
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(-camera.x, -camera.y);
    
    // Grade
    ctx.strokeStyle = '#252525';
    for(let x=0; x<=WORLD.width; x+=100) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, WORLD.height); ctx.stroke(); }
    for(let y=0; y<=WORLD.height; y+=100) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(WORLD.width, y); ctx.stroke(); }
    
    // Obstáculos
    ctx.fillStyle = '#34495e';
    obstacles.forEach(o => { ctx.fillRect(o.x, o.y, o.w, o.h); ctx.strokeStyle = '#2ecc71'; ctx.strokeRect(o.x, o.y, o.w, o.h); });

    // Itens
    items.forEach(item => {
        ctx.fillStyle = '#2ecc71';
        ctx.beginPath(); ctx.arc(item.x, item.y, 10, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'white'; ctx.fillText('+', item.x, item.y+5);
    });
    
    bots.forEach(bot => drawPlayer(bot));
    if(!isOffline && !opponent.invisible) drawPlayer(opponent);
    if(player.hp > 0) drawPlayer(player);

    projectiles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI*2); ctx.fill();
    });

    ctx.restore();
    drawMinimap();
}

function drawPlayer(p) {
    ctx.save();
    ctx.translate(p.x, p.y);
    
    // Efeito de Espada
    if(p.swordActive > 0) {
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 5;
        ctx.beginPath(); ctx.arc(0, 0, 80 + (20 - p.swordActive), 0, Math.PI*2); ctx.stroke();
    }

    ctx.fillStyle = 'white';
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(p.name + (p.level ? ` [Lvl ${p.level}]` : ''), 0, -40);
    
    ctx.fillStyle = '#444';
    ctx.fillRect(-30, -35, 60, 6);
    ctx.fillStyle = p.hp > (p.maxHp * 0.2) ? '#2ecc71' : '#ff4757';
    let lifeWidth = (Math.max(0, p.hp) / p.maxHp) * 60;
    ctx.fillRect(-30, -35, Math.min(60, lifeWidth), 6);

    ctx.globalAlpha = p.invisible ? 0.2 : 1.0;
    ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(0, 0, p.size, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = 'white'; ctx.stroke();
    ctx.restore();
}

function generateMap() {
    obstacles = [
        {x: 0, y: -50, w: WORLD.width, h: 50},
        {x: 0, y: WORLD.height, w: WORLD.width, h: 50},
        {x: -50, y: 0, w: 50, h: WORLD.height},
        {x: WORLD.width, y: 0, w: 50, h: WORLD.height}
    ];
    for(let i=0; i<30; i++) {
        obstacles.push({
            x: 300 + Math.random()*(WORLD.width-600),
            y: 300 + Math.random()*(WORLD.height-600),
            w: 100 + Math.random()*200,
            h: 100 + Math.random()*200
        });
    }
}

function checkCollision(nx, ny, size) {
    for(let o of obstacles) {
        if (nx + size > o.x && nx - size < o.x + o.w && ny + size > o.y && ny - size < o.y + o.h) return true;
    }
    return false;
}

function respawn() {
    player.hp = player.maxHp;
    let safe = false;
    while(!safe) {
        player.x = 200 + Math.random() * (WORLD.width - 400);
        player.y = 200 + Math.random() * (WORLD.height - 400);
        if(!checkCollision(player.x, player.y, player.size + 20)) safe = true;
    }
}

function spawnBot() {
    let bx, by, safe = false;
    while(!safe) {
        bx = Math.random() * WORLD.width;
        by = Math.random() * WORLD.height;
        if(!checkCollision(bx, by, 22)) safe = true;
    }
    bots.push({ x: bx, y: by, size: 22, speed: 2.5, hp: 60, maxHp: 60, color: '#f39c12', name: 'Bot NPC', lastFire: 0 });
}

function fire() {
    if(player.hp <= 0 || player.invisible) return;
    if(Date.now() - player.lastFire < player.fireRate) return;
    player.lastFire = Date.now();
    const angle = Math.atan2(mousePos.y + camera.y - player.y, mousePos.x + camera.x - player.x);
    const p = { x: player.x, y: player.y, vx: Math.cos(angle) * player.bulletSpeed, vy: Math.sin(angle) * player.bulletSpeed, owner: 'me', color: player.color, damage: player.damage };
    projectiles.push(p);
    SFX.shoot();
    sendData({ type: 'fire', p });
}

function activateSkill() {
    if(player.skillCD > 0 || player.hp <= 0) return;
    SFX.skill();
    if(player.skill === 'teleport') {
        const angle = Math.atan2(mousePos.y + camera.y - player.y, mousePos.x + camera.x - player.x);
        const tx = player.x + Math.cos(angle) * 350, ty = player.y + Math.sin(angle) * 350;
        if(!checkCollision(tx, ty, player.size)) { player.x = tx; player.y = ty; player.skillCD = 240; }
    } else if(player.skill === 'ghost') {
        player.invisible = true; player.skillCD = 600;
        setTimeout(() => player.invisible = false, 3000);
    }
}

function selectSkill(skill, el) { 
    player.skill = skill; 
    document.querySelectorAll('.skill-btn').forEach(b => b.classList.remove('selected'));
    el.classList.add('selected');
}

function showLobby() {
    audioCtx.resume();
    player.name = document.getElementById('nickname').value || 'Jogador';
    player.color = document.getElementById('playerColor').value;
    document.getElementById('main-menu').classList.add('hidden');
    document.getElementById('lobby-menu').classList.remove('hidden');
}

function backToMain() { document.getElementById('lobby-menu').classList.add('hidden'); document.getElementById('main-menu').classList.remove('hidden'); }
function startOffline() { isOffline = true; document.getElementById('ui-overlay').classList.add('hidden'); initGame(); }

/** REDE P2P **/
const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
let dataChannel;

function sendData(data) { if (dataChannel && dataChannel.readyState === 'open') dataChannel.send(JSON.stringify(data)); }

async function startHost() {
    document.getElementById('lobby-menu').classList.add('hidden');
    document.getElementById('host-setup').classList.remove('hidden');
    setupDataChannel(pc.createDataChannel("game"));
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    pc.onicecandidate = ({candidate}) => { if (!candidate) document.getElementById('offer-token').value = btoa(JSON.stringify(pc.localDescription)); };
}

async function confirmHost() {
    const val = document.getElementById('answer-token').value;
    if(!val) return;
    await pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(atob(val))));
}

async function autoGenerateAnswer() {
    const offerStr = document.getElementById('join-offer').value;
    if(offerStr.length < 50) return;
    await pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(atob(offerStr))));
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    pc.onicecandidate = ({candidate}) => { if (!candidate) document.getElementById('join-answer').value = btoa(JSON.stringify(pc.localDescription)); };
}

pc.ondatachannel = (e) => setupDataChannel(e.channel);
function setupDataChannel(ch) {
    dataChannel = ch;
    dataChannel.onopen = () => { document.getElementById('ui-overlay').classList.add('hidden'); initGame(); };
    dataChannel.onmessage = (e) => {
        const data = JSON.parse(e.data);
        if(data.type === 'pos') { Object.assign(opponent, data); opponent.swordActive = data.sa; }
        if(data.type === 'hit') { player.hp -= data.damage; SFX.hit(); if(player.hp <= 0) { sendData({type:'kill'}); respawn(); } }
        if(data.type === 'kill') { opponent.score++; }
        if(data.type === 'fire') { data.p.owner = 'opponent'; projectiles.push(data.p); SFX.shoot(); }
        if(data.type === 'sword') { opponent.swordActive = 20; SFX.sword(); }
    };
}

function drawMinimap() {
    mctx.clearRect(0, 0, miniCanvas.width, miniCanvas.height);
    const ratio = miniCanvas.width / WORLD.width;
    mctx.fillStyle = '#444';
    obstacles.forEach(o => mctx.fillRect(o.x*ratio, o.y*ratio, o.w*ratio, o.h*ratio));
    mctx.fillStyle = player.color;
    mctx.beginPath(); mctx.arc(player.x*ratio, player.y*ratio, 4, 0, Math.PI*2); mctx.fill();
    if(!isOffline) {
        mctx.fillStyle = opponent.color;
        mctx.beginPath(); mctx.arc(opponent.x*ratio, opponent.y*ratio, 4, 0, Math.PI*2); mctx.fill();
    }
}

function showJoin() { document.getElementById('lobby-menu').classList.add('hidden'); document.getElementById('join-setup').classList.remove('hidden'); }
function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; miniCanvas.width = 150; miniCanvas.height = 150; }
function gameLoop() { if(gameRunning) { update(); draw(); requestAnimationFrame(gameLoop); } }

window.addEventListener('resize', resize);
window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    if(e.key.toLowerCase() === 'r') swordAttack();
});
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
window.addEventListener('mousemove', e => { mousePos.x = e.clientX; mousePos.y = e.clientY; });
window.addEventListener('mousedown', e => { if(e.button === 0) fire(); if(e.button === 2) activateSkill(); });
window.oncontextmenu = (e) => e.preventDefault();

loadFromStorage();
resize();
</script>
</body>
</html>
